/*
 * gomacro - A Go interpreter with Lisp-like macros
 *
 * Copyright (C) 2017-2019 Massimiliano Ghilardi
 *
 *     This Source Code Form is subject to the terms of the Mozilla Public
 *     License, v. 2.0. If a copy of the MPL was not distributed with this
 *     file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *
 * generics.go
 *
 *  Created on May 12, 2019
 *      Author Massimiliano Ghilardi
 */

package xreflect

import (
	r "reflect"

	"github.com/cosmos72/gomacro/go/etoken"
	"github.com/cosmos72/gomacro/go/types"
)

// declare wrapper methods for underlying type methods

// FIXME move to github.com/cosmos72/gomacro/go/types

func (v *Universe) addTypeMethodsCTI(t Type) {
	if !etoken.GENERICS_V2_CTI {
		return
	}
	xt := unwrap(t)
	xb := unwrap(v.BasicTypes[xt.kind])
	if xb != nil && xt.gtype != xb.gtype {
		// add methods to a named type that wraps a basic type
		info := xb.gtype.(*types.Basic).Info()
		vec_t := []Type{t}
		vec_tt := []Type{t, t}
		vec_bool := []Type{v.BasicTypes[r.Bool]}
		func_tt := v.FuncOf(vec_t, vec_t, false)
		func_tt_t := v.FuncOf(vec_tt, vec_t, false)
		if info&types.IsNumeric != 0 {
			xt.AddMethod("Add", func_tt_t)
			xt.AddMethod("Sub", func_tt_t)
			xt.AddMethod("Mul", func_tt_t)
			xt.AddMethod("Quo", func_tt_t)
			xt.AddMethod("Neg", func_tt_t)
		} else if info&types.IsString != 0 {
			vec_int := []Type{v.BasicTypes[r.Int]}
			vec_byte := []Type{v.BasicTypes[r.Uint8]}
			vec_tint := []Type{t, v.BasicTypes[r.Int]}
			xt.AddMethod("Add", func_tt_t)
			xt.AddMethod("Get", v.FuncOf(vec_tint, vec_byte, false))
			xt.AddMethod("Len", v.FuncOf(vec_t, vec_int, false))
		}
		if info&types.IsInteger != 0 {
			func_tbytet := v.FuncOf([]Type{t, v.BasicTypes[r.Uint8]}, vec_t, false)
			xt.AddMethod("Rem", func_tt_t)
			xt.AddMethod("And", func_tt_t)
			xt.AddMethod("Andnot", func_tt_t)
			xt.AddMethod("Or", func_tt_t)
			xt.AddMethod("Xor", func_tt_t)
			xt.AddMethod("Not", func_tt) // unary ^
			xt.AddMethod("Shl", func_tbytet)
			xt.AddMethod("Shr", func_tbytet)
		} else if info&types.IsComplex != 0 {
			var float Type
			if b.kind == Complex64 {
				float = v.BasicTypes[r.Float32]
			} else {
				float = v.BasicTypes[r.Float64]
			}
			func_t_float := v.FuncOf(vec_t, []Type{float}, false)
			xt.AddMethod("Real", func_t_float)
			xt.AddMethod("Imag", func_t_float)
		} else if info&types.IsBoolean != 0 {
			xt.AddMethod("Not", func_tt)
		}

		func_ttbool := v.FuncOf(vec_tt, vec_bool, false)
		xt.AddMethod("Equal", func_vvbool) // always present
		if info&types.IsOrdered != 0 {
			xt.AddMethod("Less", func_vvbool)
		}
	} else {
		k := xt.kind
		if hasCapLen(k) {
			func_t_int := v.FuncOf(vec_t, vec_int, false)
			xt.AddMethod("Cap", func_t_int)
			xt.AddMethod("Len", func_t_int)
		}
		if hasGetSet(k) {
			xt.AddMethod("Get", v.FuncOf([]Type{t, v.BasicTypes[r.Int]}, []Type{t.elem()}, false))
			xt.AddMethod("Set", v.FuncOf([]Type{t, v.BasicTypes[r.Int], t.elem()}, nil, false))
		}
		xt.AddMethod("GetAddr", func_tint_ptrelem)


		case r.Chan:
		NewFunc(token.NoPos, nil, "Cap", NewSignature(v, nil, tuple_int, false)),
		NewFunc(token.NoPos, nil, "Len", NewSignature(v, nil, tuple_int, false)),
		NewFunc(token.NoPos, nil, "Close", NewSignature(v, nil, nil, false)),
	}
	if c.dir == SendRecv || c.dir == RecvOnly {
		c.methods = append(c.methods,
			NewFunc(token.NoPos, nil, "Recv", NewSignature(v, nil, tuple_elem_bool, false)),
		)
	}
	if c.dir == SendRecv || c.dir == SendOnly {
		c.methods = append(c.methods,
			NewFunc(token.NoPos, nil, "Send", NewSignature(v, tuple_elem, nil, false)),
		)
		case r.Map:
		NewFunc(token.NoPos, nil, "Delete", NewSignature(v, tuple_int, nil, false)),
		NewFunc(token.NoPos, nil, "Get", NewSignature(v, tuple_int, tuple_elem, false)),
		NewFunc(token.NoPos, nil, "Len", NewSignature(v, nil, tuple_int, false)),
		NewFunc(token.NoPos, nil, "Set", NewSignature(v, tuple_int_elem, nil, false)),
		case r.Slice:
		NewFunc(token.NoPos, nil, "Append", NewSignature(v, tuple_v, tuple_v, true)),
		NewFunc(token.NoPos, nil, "Cap", NewSignature(v, nil, tuple_int, false)),
		NewFunc(token.NoPos, nil, "Copy", NewSignature(v, tuple_v, nil, false)),
		NewFunc(token.NoPos, nil, "Get", NewSignature(v, tuple_int, tuple_elem, false)),
		NewFunc(token.NoPos, nil, "GetAddr", NewSignature(v, tuple_int, tuple_ptrelem, false)),
		NewFunc(token.NoPos, nil, "Len", NewSignature(v, nil, tuple_int, false)),
		NewFunc(token.NoPos, nil, "Set", NewSignature(v, tuple_int_elem, nil, false)),
		}
	}
	if xb != nil && xt.rtype == xb.rtype {
		v.addBasicTypeMethodsCTI(t)
	} else {
		v.addReflectTypeMethodsCTI(t)
	}
}
